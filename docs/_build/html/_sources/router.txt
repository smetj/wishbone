======
Router
======

The :py:class:`wishbone.router.Default` router is used to initialize the
modules and to organize the event stream between them.

Modules are registered using :py:func:`wishbone.router.Default.register`. The
router takes care of the proper startup
:py:func:`wishbone.router.Default.start` and shutdown
:py:func:`wishbone.router.Default.start` sequence of all the modules.

Queues are connected to each other using
:py:func:`wishbone.router.Default.connect`.  Queues can only have a "1 to 1"
relationship.  If you require a "1 to N" or similar scenario you might have to
use one of the builtin flow modules.

The router also takes care of the logs and metrics produced by the modules. By
registering Wishbone modules using the
:py:func:`wishbone.router.Default.registerLogModule` and
:py:func:`wishbone.router.Default.registerMetricModule` we can pretty much do
what we want with them.


Throttling
==========

The default router contains basic support for throttling.  When throttling is
enabled by setting the the `throttle` variable to True, a greenthread scans
periodically  all initialized modules to detect instances which have more
events queued than defined in the `throttle_threshold` variable.  Once such a
module is found, all upstream parent modules are identified and verified which
one is the source of overflowing the children. When the parent module is
identified, the router calls the
:py:func:`wishbone.Actor.enableThrottling` and
:py:func:`wishbone.Actor.disableThrottling` accordingly.

It is up to the author of the module to override these functions and have them
make correct measurements.


Logging
=======

Modules produce logs using :py:class:`wishbone.tools.QLogging`.  These logs
are automatically collected by the router and are put into a queue within the
router instance.  By using :py:func:`wishbone.router.registerLogModule` we can
connect whatever to process the logstream in whatever way.

Typically the :py:class:`wishbone.module.LogLevelFilter` is registered with
:py:func:`wishbone.router.Default.registerLogModule` to filter out the
interesting loglevels before sending the logstream to any other modules such
as :py:class:`wishbone.module.Syslog` or :py:class:`wishbone.module.STDOUT`.


Metrics
=======

Modules produce 2 kinds of metrics:

    -   Queue related metrics which are generated by
        :py:func:`wishbone.tools.WishboneQueue.stats`.

    -   Function related metrics can optionally be generated by decorating a
        function with :py:func:`wishbone.tools.Measure.runTime`


The router instance is responsible for grabbing the metrics at the
:py:data:`wishbone.router.Default.interval`.  The gathered metrics are stored
in the router's metrics queue from which they can be consume by the module
which has been registered using
:py:func:`wishbone.router.Default.registerMetricModule`

Typically the :py:class:`wishbone.module.Graphite` is registered as
metricmodule, which formats the metrics into a Graphite format.  That module
can be connected on its turn to the TCP client module in order to forward the
metric data to Graphite.

.. image:: graphite.png

Format
------
Wishbone represents metrics into a fixed data structure:

    (time, type, source, name, value, unit, (tag1, tag2))

It is a tuple containing a number of fields:

- timestamp
  A timestamp of the metric in unix time.

- type
  A free to choose description of the type of the metric

- source
  The originating source of the metric

- name
  The name of the metric

- value
  The metric value

- unit
  The value units

- tags
  A tuple of tags

For example:

        (1381002603.726132, 'wishbone', 'hostname', 'queue.outbox.in_rate', 0, '', ("production",monitored))

---------

.. autoclass:: wishbone.router.Default
    :members:

---------

.. autoclass:: wishbone.tools.Measure
    :members: runTime